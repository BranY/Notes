<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.1.1 (456663)"/><meta name="altitude" content="11.34327030181885"/><meta name="author" content="杨文家"/><meta name="created" content="2018-05-20 04:28:29 +0000"/><meta name="latitude" content="30.19548121875649"/><meta name="longitude" content="120.1920605062555"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-05-20 06:03:31 +0000"/><title>翻译模型理论知识</title></head><body><div><span style="background-color: rgb(255, 250, 165); font-size: 18px;-evernote-highlight:true;">词翻译模型的缺点：（词对齐信息是负信息）</span></div><ul><li><div><span style="font-family: &quot;Helvetica Neue&quot;; font-size: 14px;">以词作为翻译的最小单位，从语料库中自动学习 单词的翻译，对于一个词翻译到多个词的情况， 都分解成一个词到一个词的翻译概率，很不合理</span></div></li><li><div><span style="font-family: &quot;Helvetica Neue&quot;; font-size: 14px;">以单词为翻译粒度时很难在中文等类似语言中确定词之间的边界</span></div></li><li><div><span style="font-family: &quot;Helvetica Neue&quot;; font-size: 14px;">IBM模型只刻划了词到词的翻译概率，词翻 译的时候没有考虑上下文，难以刻划一些 固定搭配、习惯用法的翻译</span></div></li><li><div><span style="font-family: &quot;Helvetica Neue&quot;; font-size: 14px;">实际翻译任务中，容易造成翻译结果中每个词对应的翻译结果正确，但翻译顺序却不对的情况</span></div></li><li><div><span style="font-family: &quot;Helvetica Neue&quot;; font-size: 14px;">词序调整的复杂性 ，IBM模型中词语调序模型过于简单，很难刻 划复杂的词序调整规律（顺序，交叉，间断）</span></div></li></ul><div><br/></div><div><span style="font-size: 12pt; font-family: 宋体;">需预先将</span> <span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;;" /><span style="font-size: 12pt; font-family: 宋体;">部署到每个计算节点和设定模型训练序列。第一步在数据分片所在计算节点调用</span> <span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;;" /><span style="font-size: 12pt; font-family: 宋体;">得到词对齐参数的加权统计量，第二步获取所有节点本轮生成的词对齐模型训练结果进行参数的统一正则化更新。按照指定的模型训练反复执行以上两步来得到最终的词对齐结果。</span></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-size: 18px;-evernote-highlight:true;">分布式词对齐模型：</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">每轮</span><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;;">E-Step</span><span style="font-size: 12pt; font-family: 宋体;">并行计算平台</span><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;;">Spark</span><span style="font-size: 12pt; font-family: 宋体;">在语料分块所在机器调用</span> <span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;;" /><span style="font-size: 12pt; font-family: 宋体;">获取隐含变量词对齐当前轮次的参数加权统计量。这样做的目的有两个：</span></div></li><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">运用数</span><span style="font-size: 12pt; font-family: 宋体;">据并行计算平台</span><span style="font-size: 12pt; font-family: 宋体;">在数据并行上的特点，在多个节点训练来提高程序的并行度；</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">最大程度地发挥</span> <span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;;" /><span style="font-size: 12pt; font-family: 宋体;">多线程处理优势来提高模型的训练效率。</span></div></li></ul><li><div><span style="font-size: 12pt; font-family: 宋体;">在</span><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;;">M-step,</span><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;;"> </span><span style="font-size: 12pt; font-family: 宋体;">将上一步在每个计算节点产生的词对齐参数估计值从本地加载到</span><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;;">HDFS</span><span style="font-size: 12pt; font-family: 宋体;">进行统一的参数正则化。</span></div></li></ul><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-size: 18px;-evernote-highlight:true;">短语翻译模型的缺点：</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">包含词较少的短语需要调整翻译顺序 （短语的长度）</span></div></li><li><div><span style="font-size: 12pt; font-family: 宋体;">包含词较多的短语容易产生稀疏</span></div></li></ul><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-size: 18px;-evernote-highlight:true;">层次化短语翻译模型的缺点：</span></div><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">虽然引入更多的句法信息可以一定程度上提升翻译质量，然而模型训练耗时、模型结果难以存储以及解码时的不匹配等问题日益成为约束句法翻译模型发展的主要因素，所以需要翻译规则进行限制和惩罚</span></div></li><li><div><span style="font-size: 16px; font-family: 宋体;">短语的规模指数级别增长，无论是单机还是分布式训练时都存在巨大的开销</span></div></li></ul><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-family: 宋体; font-size: 18px;-evernote-highlight:true;">优化思路：</span></div><ul><li><div><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;; color: rgb(255, 38, 0);">根据模型训练流程中需要多次估计模型参数的特点，优化</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;; color: rgb(255, 38, 0);">使用</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;; color: rgb(255, 38, 0);">join</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;"><span style="font-family: &quot;Helvetica Neue&quot;; font-size: 16px; color: rgb(255, 38, 0);">算子的并行化最大似然估计算法</span>。一般</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">Spark</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">中的</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">join</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">算子很可能造成数据</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">shuffle</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">，而在数据并行计算平台上尽可能减少或避免网络和</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">I/O</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">开销是非常重要的。本文采取两种优化方案, 主要是处理两个场景：一个小表和一个大表的</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">join</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">和两个大表的</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">join (</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">这里的“表”指的是要操作的</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">RDD)</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">。针对一个小表和一个大表</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">join</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">的情况，首先</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">collect</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">小表到</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">driver</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">端，然后</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">将其广播到每个计算节点进行共享。之后在分布式大表的每个数据分区获取广播的小表来避免全局</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">join</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">。针对</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">两个分布式大表的</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">join</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">，主要是对两个待</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">join</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">的大表使用相同的自定义</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">partitioner</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">方法（或</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">Spark</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">中自带的</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">partitioner</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">）来使得它们内部数据预先满足相同的划分规则，这样两个表中需要连接的记录会预先分配到同一个节点，</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">join</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">时直接在本地完成计算。首先对两个分布式大表通过</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">partitionBy</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">算子应用相同的</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">partitioner</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">来</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">产生同一数据分区方式，然后使用</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">action</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">操作来触发表中数据的重新划分。最后两个表进行</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">join</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">时计算都在本地节点，从而避免执行过程中的数据</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">shuffle</span><span style="text-indent: 24pt; font-size: 16px; font-family: &quot;Helvetica Neue&quot;;">。</span></div></li><li><div><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;"><span style="font-family: &quot;Helvetica Neue&quot;; font-size: 12pt; color: rgb(255, 38, 0);">数据倾斜优化</span>。由于训练数据分布或数据划分方式导致的数据倾斜问题的存在（BSP模式，依赖于task最慢的worker）</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;">。第一种，使用</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;">Spark</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;">并行化编程框架自带的接口</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;">repartition</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;">（或使用</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;">repartitionAndSortWithinPartitions</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;">，需要重定义分区函数且</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;">RDD</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;">类型必须为</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;">PairRDD</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;">，通过重新划分数据分片来使得数据分布更加均匀）来适当提高程序并行度。第二种，使用两阶段聚合策略，首先对原有记录的</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;">key</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;">添加随机前缀（或后缀）进行扩展，使得记录可以均匀地分布到每个计算节点。然后在每个节点做一次局部聚合，最后去掉之前添加的前缀进行全局聚合。通过以上措施，来解决模型训练过程中单个</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;">task</span><span style="font-size: 12pt; font-family: &quot;Helvetica Neue&quot;;">处理数据量过多的问题</span></div></li></ul><div><br/></div><div><br/></div><div><br/></div><div style="text-align: center;"><img src="%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86.resources/0D6F72E4-20A9-490E-BCE0-E5240CA9A0A7.png" height="1176" width="1766"/><img src="%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86.resources/5D09A0F9-1336-4A5C-B6EB-E6F9FF40F6B1.png" height="1006" width="1828"/><br/></div><div style="text-align: center; "><img src="%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86.resources/6AC415BA-C922-4438-AE8E-F0EF2445B911.png" height="906" width="1774"/><img src="%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86.resources/2627AA37-2AC7-48A9-AC79-5212666B4D88.png" height="1040" width="1738"/><br/></div><div><br/></div><div><img src="%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%9E%8B%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86.resources/BE508CEB-B284-4E2C-87BD-F42847DBBE39.png" height="866" width="1794"/><br/></div><div><br/></div></body></html>